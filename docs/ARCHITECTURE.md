# idleKV 架构设计文档

## 系统概览

idleKV是一个基于Adaptive Radix Tree (ART)的高性能内存键值数据库，采用分层架构设计，支持MVCC并发控制、WAL持久化和GPU查询加速。

## 架构分层

```
┌─────────────────────────────────────────────────────────┐
│                    接口层 (Interface Layer)              │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │  Redis Protocol │  │   Native API    │              │
│  │     Handler     │  │                 │              │
│  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────┤
│                    执行层 (Execution Layer)              │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │  Transaction    │  │  Query Scheduler│              │
│  │    Manager      │  │   (CPU/GPU)     │              │
│  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────┤
│                    索引层 (Index Layer)                  │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │   ART Index     │  │   GPU ART       │              │
│  │    (CPU)        │  │   (CUDA)        │              │
│  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────┤
│                  内存管理层 (Memory Layer)                │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │      MVCC       │  │      EBR        │              │
│  │   Version Mgr   │  │  Memory Mgr     │              │
│  └─────────────────┘  └─────────────────┘              │
├─────────────────────────────────────────────────────────┤
│                   持久化层 (Storage Layer)                │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │   WAL Manager   │  │ Snapshot Manager│              │
│  │                 │  │                 │              │
│  └─────────────────┘  └─────────────────┘              │
└─────────────────────────────────────────────────────────┘
```

## 核心组件详解

### 1. ART索引结构

#### 节点类型
- **Node4**: 最多4个子节点，紧凑存储
- **Node16**: 最多16个子节点，支持SIMD优化
- **Node48**: 最多48个子节点，使用索引映射
- **Node256**: 最多256个子节点，直接数组访问

#### 关键特性
- **路径压缩**: 压缩单分支路径，减少内存使用
- **SIMD优化**: Node16使用SIMD指令加速查找
- **缓存友好**: 紧凑的内存布局，提高缓存命中率

### 2. MVCC并发控制

#### 版本管理
```cpp
struct VersionRecord {
    TxnId txn_id;           // 事务ID
    Timestamp begin_ts;     // 开始时间戳
    Timestamp end_ts;       // 结束时间戳
    Value value;            // 数据值
    VersionRecord* next;    // 版本链表
    bool is_deleted;        // 删除标记
};
```

#### 事务执行流程
1. **Read Phase**: 构建读写集合
2. **Validation Phase**: OCC冲突检测
3. **Write Phase**: 提交或回滚

### 3. Epoch-Based Reclamation

#### 内存回收机制
- **Epoch管理**: 全局epoch计数器
- **线程本地epoch**: 每个线程维护本地epoch
- **延迟回收**: 在安全epoch回收内存
- **无锁设计**: 避免回收时的锁竞争

### 4. WAL持久化

#### 日志格式
```cpp
struct WALRecord {
    WALRecordType type;     // 记录类型
    TxnId txn_id;          // 事务ID
    Timestamp timestamp;    // 时间戳
    uint32_t key_size;     // 键长度
    uint32_t value_size;   // 值长度
    uint32_t crc32;        // 校验和
    // 变长数据: key + value
};
```

#### 写入策略
- **Group Commit**: 批量提交减少IO
- **异步同步**: 后台线程定期fsync
- **CRC校验**: 保证数据完整性

### 5. GPU查询加速

#### 设计原则
- **批量处理**: 只对批量查询使用GPU
- **内存布局优化**: 按节点类型分离存储
- **异构调度**: CPU/GPU智能调度

#### 适用场景
- 批量点查询 (batch size > 100)
- 批量范围扫描
- 只读查询负载

## 性能优化策略

### 1. 缓存优化
- **内存预取**: 预取可能访问的节点
- **数据局部性**: 相关数据紧密存储
- **NUMA感知**: 考虑NUMA架构的内存访问

### 2. 并发优化
- **无锁读取**: 读操作完全无锁
- **细粒度锁**: 写操作使用细粒度锁
- **读写分离**: 读写操作互不阻塞

### 3. SIMD优化
- **向量化比较**: 使用SIMD指令并行比较
- **批量操作**: 向量化的批量插入/删除
- **编译器优化**: 启用自动向量化

## 扩展性设计

### 1. 水平扩展
- **分片支持**: 支持数据分片
- **一致性哈希**: 动态分片重平衡
- **分布式事务**: 跨分片事务支持

### 2. 垂直扩展
- **多核利用**: 充分利用多核CPU
- **内存扩展**: 支持大内存配置
- **存储分层**: 热冷数据分离

## 容错与恢复

### 1. 崩溃恢复
1. 加载最新快照
2. 重建ART索引
3. 回放WAL日志
4. 重建内存状态

### 2. 数据一致性
- **原子性**: 事务要么全部成功要么全部失败
- **一致性**: 维护数据库约束
- **隔离性**: 事务间相互隔离
- **持久性**: 已提交事务持久化存储

## 监控与调试

### 1. 性能指标
- **吞吐量**: QPS统计
- **延迟**: P50/P95/P99延迟
- **内存使用**: 索引/版本/缓存内存
- **GPU利用率**: GPU查询统计

### 2. 调试工具
- **索引可视化**: ART结构可视化
- **事务跟踪**: 事务执行路径
- **内存分析**: 内存泄漏检测
- **性能剖析**: CPU/GPU性能分析